# jig - Just-in-time Generics for Go

In the summer of 2017 while everything was nice and quiet at [work](https:///simplemind.eu), I set out to find a way to add generic programming to Go. The biggest hurdle was to avoid code generation bloat. So I implemented a demand driven approach that would result in the automatic generation of the minimal amount of code for a specific combination of types. The result is called *Just-in-time Generics for Go*. Or **jig** for short.

If you're more a 'learning by doing' kind of person, check out the `rx` library [Quick Start](https://github.com/reactivego/rx/doc/quickstart.md). It demonstrates how to write code using the `rx` template library and how to use *jig* to generate code for the used templates.

## Rationale
For more than a year, I've been working regularly in my spare time on implementing ReactiveX for Go using idiomatic strongly typed Go code. In order to do this I needed a way to write code that is independent of any particular combination of types; I needed generics. I have to confess that I'm actually not that fond of generics. Bad experiences with gibberish error messages and massive code bloat in C++ had soured me on the paradigm.

I've tried more than a handful of generic programming and code generation solutions for Go. None of these were powerfull enough to satisfy my requirements. So I decided to take a stab at creating a generic programming solution for Go myself. The rules I set out for myself to follow were:

- Generic code has to be proper Go code that can be build with `go build` directly.
- Generic code has to be testable Go code that can be tested with `go test` directly.
- A generic code package should be a normal Go package that can be downloaded using `go get` directly.
- Code generated from generic code should be the minimum required to make a program work.

## What is a Jig?
I actually thought of the name *jig* before I knew what it meant, but after I found out, I was sure I had chosen the right name.
A [*jig*] is a device used in the manufacturing of products to hold the work and to guide a tool. An example of a *jig* is when a key is duplicated; the original is used as a *jig* so the new key can have the same path as the old one.

For this project, a *jig* is defined as a working piece of code that is written in terms of place-holder types and that is then used to generate code for specific (combinations of) types.

```go
//jig:template <Foo>Stack Push

func (s *FooStack) Push(v foo) {
    *s = append(*s, v)
}
```

Jig templates should be fairly granular. Every type and every method associated with that type and every function is normally stored in its own `jig:template`. The reason for that is that methods on which your code does not depend will be left out of the generated code. Also if the templates are not granular enough *jig* may e.g. fail to find a template for a missing method. In practice these issues are quickly detected and fixed during template library development while you write tests for your library and *jig* reports errors about things it can't generate.

## Unique selling points

1. Compiler driven code generation to minimize the amount of code generated.
2. No explicit declaration of template specialization, automatic specialization by looking at code that uses the templates.
3. Templates are working Go code that can be tested and build.
4. A template package is a normal Go gettable package.
5. Templates can be specialized to a specific type (e.g. `int32`, `string`) **or** to the *any* type (i.e. `interface{}`).

To my knowledge **jig** is the only generic programming tool for Go that generates the absolutely minimal amount of code. Also, templates are written as idiomatic Go code with place-holder types. Code using the templates doesn't need specific template declarations. Building and testing code works normally. There are no cryptic error messages. And on top of that, you can generate code for specific types or you can choose to generate code for the `interface{}` type.

## Command-Line

To install *jig*, open a terminal screen and type:
```bash
go get github.com/reactivego/jig
```

To get help:

```bash
Mac:~ $ jig --help
Usage of jig [flags] [<dir>]:
  -c, --clean     Remove files generated by jig
  -r, --regen     Force regeneration of all code by jig
  -v, --verbose   Print details of what jig is doing
```

The *jig* command is a self-contained single binary file. When you are working on a program you open a terminal and change to the directory of the code you are developing. Running *jig* without any parameters will make *jig* find out what types are missing and then generate and add this new code to the already exisiting code.

By default *jig* is quiet unless it finds an error. To make *jig* more chatty use the `--verbose` flag. 

You can also run *jig* with the `--regen` flag to force it to re-generate all code it had already generated previously. This is useful for when the template library has changed, or when you are no longer using some types in your code to clean out generated code no longer needed.

The templates *jig* uses are picked up from the packages that are imported by your code. So if your code is not importing a library *jig* will not find it. So it is not enough to use `go get <template library>` to install the library in your `GOPATH`, you will also need to `import _ "<template library>"` it in your code. To see what templates *jig* is finding and where, run `jig --regen --verbose` or more succinctly `jig -rv`. So, like this:

```bash
Mac:example $ jig --rv
removing file "stack.go"
found 5 jig templates in package "github.com/reactivego/jig/example/stack" 
...
```

*Jig* works by repeatedly compiling your code. Every compile cycle it may get back several errors that tell it about missing types or missing methods. *Jig* then creates type signatures for these errors and then goes through all the templates it knows of to see if it can specialize them so they'll fix the errors. After generating all the code it can, *jig* will then load the whole program into memory again and compile it again. *Jig* knows when to stop, when either no more errors were found or when no code could be generated to fix an error. At that time remaining errors are reported to the screen.

## Writing Generic Code

### Directory Structure
**To be specified**

### Defining Templates
The approach we take with *jig* is to have generic code written in terms of place-holder types like `Foo` and `Bar`. These are called [metasyntactic](https://en.wikipedia.org/wiki/Metasyntactic_variable) type names. So using these type names you can write normal Go code that will compile when you `go build` it. Let's look at an extremely simple example; a stack with just a `Push` and `Pop` method:

```go
package stack

type foo int

type FooStack []foo

func (s *FooStack) Push(v foo) {
	*s = append(*s, v)
}

func (s *FooStack) Pop() (foo, bool) {
	var zeroFoo foo
	if len(*s) == 0 {
		return zeroFoo, false
	}
	i := len(*s) - 1
	v := (*s)[i]
	*s = (*s)[:i]
	return v, true
}
```

So this is pretty normal strongly typed Go code. We note a couple of things here:

1. A place-holder type `foo` is introduced.
2. The definition of the type `FooStack`, `Push` and `Pop` methods in terms of the `foo` type.
3. You're not bound to using e.g. `Foo` and `Bar`, you can use any place-holder name you want, really.
4. Note the use of both Foo and foo. This is needed if you want the templates to work with non-exported types and built-in types.

This code will compile, and you can write tests to validate the code. Jig will use the code as a template for generating specializations where the place-holder type is replaced by another type, but also the use of those place-holders names in identifiers and even comments will be replaced with proper type names by *jig*.

However, in order to operate correctly, jig needs some help in determining what's part of a template and what's just support code. For that we use comment pragmas to tell jig what's what. To tell jig about templates we use `jig:template`. Below, we've added these pragmas to the generic stack code:

```go
package stack

type foo int

//jig:template <Foo>Stack

type FooStack []foo

//jig:template <Foo>Stack Push

func (s *FooStack) Push(v foo) {
	*s = append(*s, v)
}

//jig:template <Foo>Stack Pop

func (s *FooStack) Pop() (foo, bool) {
	var zeroFoo foo
	if len(*s) == 0 {
		return zeroFoo, false
	}
	i := len(*s) - 1
	v := (*s)[i]
	*s = (*s)[:i]
	return v, true
}
```

Again, we note a couple of things here:

1. Three templates are declared: type `<Foo>Stack` and methods `<Foo>Stack Push` and `<Foo>Stack Pop`.
2. There **must** be no space in front of the `jig:template` pragma declaration.
3. There **must** be an empty line after the template declaration line.
4. Do you see how we use &lt; and &gt; to tell jig what part of the identifier is a type var?
5. In the code where we write `foo` we mean the actual type and `Foo` means the capitalized refer type used in e.g. identifiers.

The information provide by these three pragmas is enough for jig to work with. This simple stack is on github as part of the jig example code. To use it `import _ "github.com/reactivego/jig/example/stack"`.

### Using Templates
Now let's create a little program that uses this generic stack:

```go
package main

import (
	_ "github.com/reactivego/jig/example/stack"
)

//jig:file stack.go

func main() {
	var s StringStack
	s.Push("Hello, World!")
}
```

Things to note are:

1. We are importing the stack template package purely so jig can access its contents as we use _ as the name.
2. The `jig:file` pragma tells jig to store generated code in a file named `stack.go`
3. We create a `StringStack` variable to indicate we want a stack of strings.
4. Jig knows all built-in types and knows that `String` really means the actual type `string`.

After dropping to the command-line and changing to the directory where this file is located, we run jig.

`jig`

If everything went well you will see no output message, but the following code is now present in the file `stack.go`.

```go
// Code generated by jig; DO NOT EDIT.

//go:generate jig --regen

package main

//jig:name StringStack

type StringStack []string

//jig:name StringStackPush

func (s *StringStack) Push(v string) {
	*s = append(*s, v)
}
```

Things to note are:

1. The first line showing that this code was generated by jig.
2. A `go:generate` pragma to run jig again when you run `go generate` on the command-line.
3. The generated `jig:name` pragmas uniquely identify every fragment of generated code.
4. All occurrences of `Foo` in the templates have been replaced with `String`.
5. All occurrences of `foo` in the templates have been replaced with `string`.
6. There is no implementation of `Pop` in the generated code, because it isn't needed!

When we run `go run main.go stack.go` the program will be build and run correctly.


**now add use of Pop to program**

**change use of StringStack to Stack**

**call jig -r again**

**show that code is now using interface{}**

**show Pop has been generated**

**run program again**

**show output**

**mention you can switch back to StringStack by just changing Stack to StringStack and running `go generate`**

## Advanced Subjects

In the previous sections we've been looking at just the surface of what's possible with jig. We now look at the more advanced subjects that really show the power of this generic programming tool.

### Working with Non-exported types

**Explain how non-exported types are treated**

### Specifying Template Needs

**Explain why using jig:needs speeds up  codegen**

**Explaing how jig:needs influences generated code order**


### Using jig inside a Template Package

In order for template code to compile it normally needs code that you would generate when using the template package. An example can be found in `rx` where to implement the template code for mapping from one observable to another you need to have both type `ObservableFoo` as well as type `ObservableBar` available. However `ObservableFoo` is the template and `ObservableBar` is just an instance of that template for the `bar` type.

Fortunately, *jig* has been designed to fully support this. You just need to take some precautions by instructing the generator of *jig* exactly what to generate.

**show how this is setup for rx to illustrate**

### General Support Code

**generator pragma**

**explain what jig:support means and why we need it**

**explain how jig:support is problematic if you use jig to generate code inside template package**

### Type Signature Matching

**explain details about template ordering related to length and # template vars**

### Struct Embedding

**show the use of jig:embeds and why it is important**

### Revision Handling

**explain why code revisions are different from normal go code packages**

**show how Revision123() can be used to make your code depend on a certain code revision**

**what to do in case your code fails because RevisionXXXX() is not longer available in the package***

### First and Higher order types

**explain how generation of higher order types works**

### What about interface{}?
Choosing whether to use [the empty interface](https://tour.golang.org/methods/14) isn't really about generic programming. It's the solution to reach for when you want to store heterogeneous types in the same container. So if you want to store `int`, `string` and `struct` values in the same `slice` or `map`, then `interface{}` is what you want to use. The cost, of course, is that you then need to typecast the values you retrieve back into the correct type before you can use them.

Another reason you may want to consider using code specified in terms of the empty interface, is if the implementation is very large but not type specific and you are instantiating it a lot. In that case a strongly typed implementation could be implemented by using an implementation defined in terms of the empty interface. Thus, retaining strong type checks at the cost of an extra indirection through `interface{}` based generic code.

By the way, *jig* is capable of specializing generic code in terms of `interface{}` just as easy as in terms of specific types.

**show an example of simple program using Stack to show generation code that uses empty interface**

### Pragma Reference

**explain difference between template and generator pragmas**

#### Template Pragmas

##### jig:template
The pragma `jig:template` defines the start of a new template. Consequently, it also marks the end of any previous template.

##### jig:support
The pragma `jig:support` marks this template as purely for support needed by every generated template. There is generally just a single template marked as `jig:support` because there is normally only a small ammount of support code.

The reason we even need this is because code inside the template library package cannot refer to code inside that same package by package name. If that was allowed by Go, it would create an import cycle. We want the templates to still build like normal Go code, so we refer to the shared code directly and have it also written to the package that is using the templates.

##### jig:needs
The pragma `jig:needs` indicates what other templates this template needs for its own implementation. Although needs is optional, it guides the order of code generation as needed templates are generated first.

##### jig:embeds
The pragma `jig:embeds` can be used to tell jig that a certain type embeds other types. Generating a method for an embedded type could satisfy a missing method that is needed but that the curent type does not specify a template for. Code generation will then specialize the template code for the embedded type.

##### jig:end
The pragma `jig:end` explicitly marks the end of a template.

#### Generator Pragmas

#### jig:name
The pragma `jig:name` is actually generated by jig itself to identify generated code fragments. When read back by the generator it knows which fragments are already present and it will be able to generate only the code that is really needed.
E.g. ObservableInt32MapFloat32 might be a name that is written out for code generated for a template named "Observable<Foo> Map<Bar>" and using types int32 and float32 for Foo and Bar respectively.

##### jig:file
The generator pragma `jig:file` defines the template for the filenames to use when generating fragments. In the definition you can use the variables `{{.Package}}`, `{{.package}}`, `{{.Name}}` and `{{.name}}`. Package is the name of the package that contains the jig template being expanded and Name is the signature of the source fragment being expanded. Capitalized variables are created via `strings.Title(var)` and lowercase variant are create via `strings.ToLower(var)` allowing full control over the generated filename.
Examples, assuming the template package name is 'rx':

```
jig.go				  -> jig.go
jig{{.Package}}.go 	  -> jigRx.go
{{.package}}{{.Name}} -> rxObservableInt32.go
```

By default when `jig:file` is not found the filename template `jig{{.Package}}{{.Name}}.go` is used. This will cause every code fragment to be generated into its own file.

##### jig:type
The pragma `jig:type` allows you to specify the actual type for a refer type. Useful for specializing generic code for unexported types. e.g. `//jig:type Woot woot` In this case `Woot` would be used in the derive type names, functions and methods identifiers. Whereas the actual type is used in parameters and variable types.

##### jig:no-support-code-generation
The pragma `jig:no-support-code-generation` tells the generator to not generate code for templates explicitly marked with pragma `jig:support` or for templates that are mentioned in a `jig:needs` pragma of other templates and that are not specialized on a template variable. This is only needed in template packages when using jig to generate supplemental code to support the main templates. In that case because you're generating in the library itself, the support code is already there and generating it again would create duplicate symbols.

## Further Reading

In the end I think I've created a pretty compelling solution. Jig is pretty close to perfect for what I need it for. In order to understand how to use *jig* we advice you to look at the template packages that have been created for it.

- [github.com/reactivego/rx](https://www.github.com/reactivego/rx/)


## Acknowledgments

I would not have been able to write *jig* without the excellent tooling of the *Go* project. *Jig* is build on top of `golang.org/x/tools/go/loader` and uses it to perform the compilation and error detection steps. The code generation feature uses standard *Go* `text/template`. The templates are generated and compiled on the fly from the code *jig* finds in the template libraries that are imported by the code under development. Error analysis and type signature matching is all done using the standard `regexp` package. 


## License

This library is licensed under the terms of the MIT License. See [LICENSE](LICENSE) file in this repository for copyright notice and exact wording.

[*jig*]: https://en.wikipedia.org/wiki/Jig_(tool)

