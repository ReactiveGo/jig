package pkg

import (
	"bufio"
	"bytes"
	"fmt"
	"go/ast"
	"math"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"text/template"

	"golang.org/x/tools/imports"
)

// ScanForGeneratedSources looks in the comments of the file for comment pragma //jig:name and
// adds the name to the list of generated source fragments. This allows multiple source fragments to
// be stored in a single file.
func (p *Package) ScanForGeneratedSources(file *ast.File) {
	for _, cgroup := range file.Comments {
		for _, comment := range cgroup.List {
			if strings.HasPrefix(comment.Text, jigName) {
				kvmatch := reCommentPragma.FindStringSubmatch(comment.Text)
				if len(kvmatch) == 3 {
					if kvmatch[1] == jigName {
						path := p.Filepath(file)
						p.generated[kvmatch[2]] = path
						p.fileset[path] = file
					}
				}
			}
		}
	}
}

// HasGeneratedSource is used in the templ.PackageWriter interface to prevent
// fragments from being generated multiple times.
func (p *Package) HasGeneratedSource(name string) bool {
	_, present := p.generated[name]
	return present
}

// GenerateSource will take the passed name and source and add it to the package.
// You want multiple generated fragments to share a physical file on disk.
func (p *Package) GenerateSource(packageName, name, source string) error {
	return p.GenerateSourceAppendFile(p.filename, packageName, name, source)
}

// GenerateSourceAppendFile will generate the source and append it to a
// shared source file. Duh!
func (p *Package) GenerateSourceAppendFile(filename *template.Template, packageName, name, source string) error {
	sourcebuf := &bytes.Buffer{}
	data := map[string]string{
		"Package": strings.Title(packageName),
		"package": strings.ToLower(packageName),
		"Name":    strings.Title(name),
		"name":    strings.ToLower(name),
	}
	filenamebuf := &bytes.Buffer{}
	filename.Execute(filenamebuf, data)
	path := filepath.Join(p.Dir, filenamebuf.String())
	if file, present := p.fileset[path]; present {
		err := p.WriteFile(sourcebuf, file)
		if err != nil {
			return err
		}
	} else {
		fmt.Fprintf(sourcebuf, "// Code generated by jig; DO NOT EDIT.\n\n//go:generate jig --regen\n\npackage %v\n\n", p.Name)
	}

	// Append the source fragment to the source.
	fmt.Fprintf(sourcebuf, "\n%s %s\n\n%v", jigName, name, source)

	// Rewrite imports clause for the source.
	fixedsource, err := imports.Process("", sourcebuf.Bytes(), nil)
	if err != nil {
		return newSourceError(sourcebuf, err)
	}

	file, err := p.Config.ParseFile(path, string(fixedsource))
	if err != nil {
		return newSourceError(bytes.NewBuffer(fixedsource), err)
	}

	// Add file to the fileset, idempotent
	p.AddFile(file)

	// Remember this file as the most current one.
	p.generated[name] = path
	return nil
}

func newSourceError(sourcebuf *bytes.Buffer, err error) error {

	reErr := regexp.MustCompile("^[^0-9]*([0-9]+):(.*)$")
	strErr := err.Error()
	lineErr := 0
	decWidth := 5
	result := reErr.FindStringSubmatch(strErr)
	if len(result) == 3 {
		if lineErr, err = strconv.Atoi(result[1]); err == nil {
			decWidth = int(math.Ceil((math.Log10(float64(lineErr)))))
			decWidth++
			strErr = fmt.Sprintf("%*d:%s\n", decWidth, lineErr, result[2])
		}
	}

	dumpbuf := &bytes.Buffer{}
	line := 1
	scanner := bufio.NewScanner(sourcebuf)
	for scanner.Scan() {
		fmt.Fprintf(dumpbuf, "%*d  %s\n", decWidth, line, scanner.Text())
		if line == lineErr {
			break
		}
		line++
	}

	return fmt.Errorf("%v\n%v", dumpbuf, strErr)
}
