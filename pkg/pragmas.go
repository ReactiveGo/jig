package pkg

import "regexp"

// jigTemplate is the jig:template comment pragma that defines the start of template.
// It also marks the end of any previous template.
const jigTemplate = "//jig:template"

// jigCommon is the jig:common comment pragma that marks this template as purely
// for common support code needed by every generated template.
const jigCommon = "//jig:common"

// jigNeeds is the comment pragma jig:needs that indicates what other templates this
// template needs for its own implementation. Although needs is optional, it guides the
// order of code generation as needed templates are generated first.
const jigNeeds = "//jig:needs"

// jigEmbeds is the jig:embeds comment pragma that can be used to hint jig that a certain
// types embeds other types. Generating a method for an embedded type could satisfy a missing
// method that is needed but that the curent type does not specify a template for.
// Code generation will then specialize the template code for the embedded type.
const jigEmbeds = "//jig:embeds"

// jigRequiredVars contains the list of var that have to be assigned a value when for a template
// to match a specific type signature.
const jigRequiredVars = "//jig:required-vars"

// jigEnd is the jig:end pragma that explicitly marks the end of a template.
const jigEnd = "//jig:end"

// jigFile represents comment pragma //jig:file and is used in the code that is type checked.
// This pragma defines a template for the filenames to use when generating fragments.
// In the value you can use the variables{{.Package}}, {{.package}}, {{.Name}} and {{.name}}. Package is the name of
// the package that contains the jig template being expanded and Name is the signature of the source fragment
// being expanded. Capitalized variables are created via strings.Title(var) and lowecase variant are create via
// strings.ToLower(var) allowing full control over the generated filename.
// Examples:
// 	jig.go				  	 -> jig.go
//  jig{{.Package}}.go	 	 -> jigRx.go
//  {{.package}}{{.Name}}.go -> rxObservableInt32.go
const jigFile = "//jig:file"

// jigType comment pragma allows specifying the real type for a display type. It is used in
// code that is type checked. Useful for specializing generic code for unexported types.
// e.g. //jig:type Woot woot
// In this case "Woot" would be used in the derive type names, functions and methods
// identifiers. Whereas the real type is used in parameters and variable types.
const jigType = "//jig:type"

// jigName is pragma jig:name that is placed in code generated by jig.
// This pragma is written alongside generated code so we can later recognize it when reading the code back.
// E.g. ObservableInt32MapFloat32 might be a name that is written out for code generated for a
// template named "Observable<Foo> Map<Bar>" and using types int32 and float32 for Foo and Bar respectively.
const jigName = "//jig:name"

// jigForceCommon pragma instructs jig to always generate common support code.
const jigForceCommon = "//jig:force-common-code-generation"

// jigNoDoc pragma instructs jig to not include documentation in the generated code.
const jigNoDoc = "//jig:no-doc"

var (
	reCommentPragma = regexp.MustCompile("^(//jig:[-[:word:]]+)[[:space:]]+(.+)$")

	reJigType = regexp.MustCompile("^//jig:type[[:space:]]+([[:word:]]+)[[:space:]=]+([[:punct:][:word:]]+)$")

	// Extract template variables, matches will contain [["<Foo>" "Foo"] ["<Bar>" "Bar"]]
	reTemplateVar = regexp.MustCompile("<([[:word:]]+)>")
)
