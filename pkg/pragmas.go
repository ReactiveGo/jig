package pkg

import "regexp"

// jigTemplate is the jig:template comment pragma that defines the start of template.
// It also marks the end of any previous template.
const jigTemplate = "//jig:template"

// jigSupport is the jig:support comment pragma that marks this template as purely
// for support needed by every generated template.
const jigSupport = "//jig:support"

// jigNeeds is the comment pragma jig:needs that indicates what other templates this
// template needs for its own implementation. Although needs is optional, it guides the
// order of code generation as needed templates are generated first.
const jigNeeds = "//jig:needs"

// jigEmbeds is the jig:embeds comment pragma that can be used to hint jig that a certain
// types embeds other types. Generating a method for an embedded type could satisfy a missing
// method that is needed but that the curent type does not specify a template for.
// Code generation will then specialize the template code for the embedded type.
const jigEmbeds = "//jig:embeds"

// jigEnd is the jig:end pragma that explicitly marks the end of a template.
const jigEnd = "//jig:end"

// jigName is pragma jig:name that is placed in code generated by jig.
// This pragma is written alongside generated code so we can later recognize it when reading the code back.
// E.g. ObservableInt32MapFloat32 might be a name that is written out for code generated for a
// template named "Observable<Foo> Map<Bar>" and using types int32 and float32 for Foo and Bar respectively.
const jigName = "//jig:name"

// jigFile represents comment pragma //jig:file and is used in the code that is type checked.
// This pragma defines the template for the filenames to use when generating fragments.
// In the value you can use the variables{{.Package}}, {{.package}}, {{.Name}} and {{.name}}. Package is the name of
// the package that contains the jig template being expanded and Name is the sigature of the source fragment
// being expanded. Capitalized variables are created via strings.Title(var) and lowecase variant are create via
// strings.ToLower(var) allowing full control over the generated filename.
// Examples:
// 	jig.go				  -> jig.go
//  jig{{.Package}}.go 	  -> jigRx.go
//  {{.package}}{{.Name}} -> rxObservableInt32.go
const jigFile = "//jig:file"

var reCommentPragma = regexp.MustCompile("^(//jig:[[:word:]]+)[[:space:]]+(.+)$")

// jigType comment pragma allows specifying the real type for a display type. It is used in
// code that is type checked. Useful for specializing generic code for unexported types.
// e.g. //jig:type Woot woot
// In this case "Woot" would be used in the derive type names, functions and methods
// identifiers. Whereas the real type is used in parameters and variable types.
const jigType = "//jig:type"

var reJigType = regexp.MustCompile("^//jig:type[[:space:]]+([[:word:]]+)[[:space:]]+([[:word:]]+)$")

// jigNoSupport comment pragma
const jigNoSupport = "//jig:no-support"
